#!/usr/bin/env python3

import json
import os


def create_notebook(filename, title, description, cells):
    """Create a Jupyter notebook with the given cells."""
    notebook_content = {
        "cells": [
            {
                "cell_type": "markdown",
                "metadata": {},
                "source": [
                    f"# {title}\n",
                    "\n",
                    f"{description}"
                ]
            },
            {
                "cell_type": "code",
                "execution_count": None,
                "metadata": {},
                "outputs": [],
                "source": [
                    "# Import necessary modules\n",
                    "import sys\n",
                    "import os\n",
                    "\n",
                    "# Add the root directory to the path to make imports work\n",
                    "root_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
                    "if root_dir not in sys.path:\n",
                    "    sys.path.append(root_dir)\n",
                    "\n",
                    "# Import common libraries\n",
                    "import numpy as np\n",
                    "import matplotlib.pyplot as plt\n",
                    "\n",
                    "# Import the causal meta-learning library\n",
                    "from causal_meta.graph import Graph, DirectedGraph, CausalGraph\n",
                    "import causal_meta.graph.visualization as viz"
                ]
            }
        ] + cells,
        "metadata": {
            "kernelspec": {
                "display_name": "Python 3",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {
                    "name": "ipython",
                    "version": 3
                },
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": "3.8.10"
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }

    with open(filename, 'w') as f:
        json.dump(notebook_content, f, indent=1)

    print(f"Created notebook: {filename}")


# Now create each of the 5 notebooks
if __name__ == "__main__":
    # Notebook 1: Graph Classes and Operations
    graph_classes_cells = [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1. Base Graph Class\n",
                "\n",
                "The `Graph` class is the foundation for all graph implementations in the library."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a simple graph\n",
                "graph = Graph()\n",
                "\n",
                "# Add nodes\n",
                "graph.add_node('A', label='Node A', color='red')\n",
                "graph.add_node('B', label='Node B', color='blue')\n",
                "graph.add_node('C', label='Node C', color='green')\n",
                "\n",
                "# Add edges\n",
                "graph.add_edge('A', 'B', weight=0.5)\n",
                "graph.add_edge('B', 'C', weight=1.0)\n",
                "\n",
                "# Print graph info\n",
                "print(f\"Nodes: {graph.get_nodes()}\")\n",
                "print(f\"Edges: {graph.get_edges()}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2. Directed Graph Class\n",
                "\n",
                "The `DirectedGraph` class extends the base `Graph` class to provide functionality for directed edges. It includes methods for working with predecessors, successors, paths, cycles, and topological sorting."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a directed graph\n",
                "digraph = DirectedGraph()\n",
                "\n",
                "# Add nodes\n",
                "for node in ['A', 'B', 'C', 'D', 'E']:\n",
                "    digraph.add_node(node)\n",
                "\n",
                "# Add directed edges\n",
                "digraph.add_edge('A', 'B')\n",
                "digraph.add_edge('A', 'C')\n",
                "digraph.add_edge('B', 'D')\n",
                "digraph.add_edge('C', 'D')\n",
                "digraph.add_edge('D', 'E')\n",
                "\n",
                "# Visualize the directed graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(digraph, ax=ax, title=\"Directed Graph Example\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Working with Directed Graph Operations"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Examine predecessors and successors\n",
                "print(f\"Predecessors of 'D': {digraph.get_predecessors('D')}\")\n",
                "print(f\"Successors of 'A': {digraph.get_successors('A')}\")\n",
                "\n",
                "# Check for paths\n",
                "print(f\"\\nPath from 'A' to 'E': {digraph.has_path('A', 'E')}\")\n",
                "print(f\"Path from 'E' to 'A': {digraph.has_path('E', 'A')}\")\n",
                "\n",
                "# Find all paths between nodes\n",
                "paths = digraph.find_all_paths('A', 'D')\n",
                "print(f\"\\nAll paths from 'A' to 'D':\")\n",
                "for i, path in enumerate(paths, 1):\n",
                "    print(f\"  Path {i}: {path}\")\n",
                "\n",
                "# Check for cycles\n",
                "print(f\"\\nDoes the graph have cycles? {digraph.has_cycle()}\")\n",
                "\n",
                "# Create a graph with a cycle\n",
                "cycle_graph = DirectedGraph()\n",
                "for node in ['A', 'B', 'C']:\n",
                "    cycle_graph.add_node(node)\n",
                "cycle_graph.add_edge('A', 'B')\n",
                "cycle_graph.add_edge('B', 'C')\n",
                "cycle_graph.add_edge('C', 'A')\n",
                "print(f\"Does the cycle graph have cycles? {cycle_graph.has_cycle()}\")\n",
                "\n",
                "# Topological sort (works only on DAGs)\n",
                "try:\n",
                "    print(f\"\\nTopological sort of the digraph: {digraph.topological_sort()}\")\n",
                "    print(f\"Topological sort of the cycle graph: {cycle_graph.topological_sort()}\")\n",
                "except ValueError as e:\n",
                "    print(f\"Topological sort error: {e}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Adjacency Matrix Representation"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Get the adjacency matrix representation\n",
                "adjacency_matrix, node_indices = digraph.get_adjacency_matrix()\n",
                "\n",
                "print(\"Node indices:\")\n",
                "print(node_indices)\n",
                "print(\"\\nAdjacency Matrix:\")\n",
                "print(adjacency_matrix)\n",
                "\n",
                "# Visualize the adjacency matrix\n",
                "plt.figure(figsize=(8, 6))\n",
                "plt.imshow(adjacency_matrix, cmap='Blues')\n",
                "plt.colorbar(label='Edge presence')\n",
                "plt.title('Adjacency Matrix of Directed Graph')\n",
                "plt.xticks(range(len(node_indices)), list(node_indices.keys()), rotation=45)\n",
                "plt.yticks(range(len(node_indices)), list(node_indices.keys()))\n",
                "plt.grid(False)\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3. Causal Graph Class\n",
                "\n",
                "The `CausalGraph` class extends the `DirectedGraph` class with causal semantics, including methods for identifying parents, children, Markov blankets, d-separation, and interventions."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a causal graph with a fork structure: X <- Z -> Y\n",
                "fork_graph = CausalGraph()\n",
                "for node in ['X', 'Y', 'Z']:\n",
                "    fork_graph.add_node(node)\n",
                "fork_graph.add_edge('Z', 'X')\n",
                "fork_graph.add_edge('Z', 'Y')\n",
                "\n",
                "# Visualize the fork graph\n",
                "plt.figure(figsize=(8, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(fork_graph, ax=ax, title=\"Fork Causal Structure (X ← Z → Y)\")\n",
                "plt.show()\n",
                "\n",
                "# Create a causal graph with a collider structure: X -> Z <- Y\n",
                "collider_graph = CausalGraph()\n",
                "for node in ['X', 'Y', 'Z']:\n",
                "    collider_graph.add_node(node)\n",
                "collider_graph.add_edge('X', 'Z')\n",
                "collider_graph.add_edge('Y', 'Z')\n",
                "\n",
                "# Visualize the collider graph\n",
                "plt.figure(figsize=(8, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(collider_graph, ax=ax, title=\"Collider Causal Structure (X → Z ← Y)\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Working with Causal Relations"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Examining causal relationships in the fork structure\n",
                "print(\"=== Fork Structure (X ← Z → Y) ===\")\n",
                "print(f\"Parents of X: {fork_graph.get_parents('X')}\")\n",
                "print(f\"Children of Z: {fork_graph.get_children('Z')}\")\n",
                "print(f\"Markov blanket of Z: {fork_graph.get_markov_blanket('Z')}\")\n",
                "print(f\"Is Z a confounder for X and Y? {fork_graph.is_confounder('X', 'Y')}\")\n",
                "\n",
                "# D-separation in the fork structure\n",
                "print(f\"\\nAre X and Y d-separated? {fork_graph.is_d_separated('X', 'Y')}\")\n",
                "print(f\"Are X and Y d-separated given Z? {fork_graph.is_d_separated('X', 'Y', {'Z'})}\")\n",
                "\n",
                "# Examining causal relationships in the collider structure\n",
                "print(\"\\n=== Collider Structure (X → Z ← Y) ===\")\n",
                "print(f\"Parents of Z: {collider_graph.get_parents('Z')}\")\n",
                "print(f\"Is Z a collider? {collider_graph.is_collider('Z')}\")\n",
                "\n",
                "# D-separation in the collider structure\n",
                "print(f\"\\nAre X and Y d-separated? {collider_graph.is_d_separated('X', 'Y')}\")\n",
                "print(f\"Are X and Y d-separated given Z? {collider_graph.is_d_separated('X', 'Y', {'Z'})}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Intervening on Causal Graphs"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a more complex causal graph\n",
                "complex_graph = CausalGraph()\n",
                "for node in ['A', 'B', 'C', 'D', 'E']:\n",
                "    complex_graph.add_node(node)\n",
                "complex_graph.add_edge('A', 'B')\n",
                "complex_graph.add_edge('A', 'C')\n",
                "complex_graph.add_edge('B', 'D')\n",
                "complex_graph.add_edge('C', 'D')\n",
                "complex_graph.add_edge('C', 'E')\n",
                "\n",
                "# Visualize the original graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(complex_graph, ax=ax, title=\"Original Causal Graph\")\n",
                "plt.show()\n",
                "\n",
                "# Perform a do-intervention on node 'A'\n",
                "intervened_graph = complex_graph.do_intervention('A')\n",
                "\n",
                "# Visualize the intervened graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(intervened_graph, ax=ax, title=\"Causal Graph after do(A)\")\n",
                "plt.show()\n",
                "\n",
                "# Check how the intervention affected the graph structure\n",
                "print(f\"Original graph has edge A→B: {complex_graph.has_edge('A', 'B')}\")\n",
                "print(f\"Intervened graph has edge A→B: {intervened_graph.has_edge('A', 'B')}\")\n",
                "print(f\"\\nParents of 'A' in original graph: {complex_graph.get_parents('A')}\")\n",
                "print(f\"Parents of 'A' in intervened graph: {intervened_graph.get_parents('A')}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Backdoor Paths and Adjustment Sets"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a causal graph with backdoor paths\n",
                "backdoor_graph = CausalGraph()\n",
                "for node in ['X', 'Y', 'Z1', 'Z2', 'Z3']:\n",
                "    backdoor_graph.add_node(node)\n",
                "backdoor_graph.add_edge('X', 'Y')  # Direct causal effect\n",
                "backdoor_graph.add_edge('Z1', 'X')  # Backdoor path through Z1\n",
                "backdoor_graph.add_edge('Z1', 'Y')\n",
                "backdoor_graph.add_edge('Z2', 'Z1')  # Longer backdoor path\n",
                "backdoor_graph.add_edge('Z2', 'Z3')\n",
                "backdoor_graph.add_edge('Z3', 'Y')\n",
                "\n",
                "# Visualize the backdoor graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(backdoor_graph, ax=ax, title=\"Causal Graph with Backdoor Paths\")\n",
                "plt.show()\n",
                "\n",
                "# Find backdoor paths\n",
                "backdoor_paths = backdoor_graph.get_backdoor_paths('X', 'Y')\n",
                "print(\"Backdoor paths from X to Y:\")\n",
                "for i, path in enumerate(backdoor_paths, 1):\n",
                "    print(f\"  Path {i}: {path}\")\n",
                "\n",
                "# Check if certain sets are valid adjustment sets\n",
                "print(\"\\nAdjustment set validity:\")\n",
                "print(f\"Is {{Z1}} a valid adjustment set? {backdoor_graph.is_valid_adjustment_set('X', 'Y', {'Z1'})}\")\n",
                "print(f\"Is {{Z2}} a valid adjustment set? {backdoor_graph.is_valid_adjustment_set('X', 'Y', {'Z2'})}\")\n",
                "print(f\"Is {{Z1, Z3}} a valid adjustment set? {backdoor_graph.is_valid_adjustment_set('X', 'Y', {'Z1', 'Z3'})}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 4. Advanced Graph Operations\n",
                "\n",
                "Now let's explore some more advanced operations on graphs, including graph traversal, component analysis, and structural properties."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a disconnected directed graph\n",
                "disconnected_graph = DirectedGraph()\n",
                "for node in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']:\n",
                "    disconnected_graph.add_node(node)\n",
                "\n",
                "# Add edges to create two separate components\n",
                "disconnected_graph.add_edge('A', 'B')\n",
                "disconnected_graph.add_edge('B', 'C')\n",
                "disconnected_graph.add_edge('C', 'A')\n",
                "\n",
                "disconnected_graph.add_edge('E', 'F')\n",
                "disconnected_graph.add_edge('F', 'G')\n",
                "disconnected_graph.add_edge('G', 'H')\n",
                "disconnected_graph.add_edge('H', 'E')\n",
                "\n",
                "# Visualize the disconnected graph\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(disconnected_graph, ax=ax, title=\"Disconnected Directed Graph\")\n",
                "plt.show()\n",
                "\n",
                "# Check if the graph is connected (it shouldn't be)\n",
                "print(f\"Is the graph connected? {disconnected_graph.is_connected()}\")\n",
                "\n",
                "# Find connected components\n",
                "components = disconnected_graph.get_connected_components()\n",
                "print(\"\\nConnected components:\")\n",
                "for i, component in enumerate(components, 1):\n",
                "    print(f\"  Component {i}: {component}\")\n",
                "\n",
                "# Check for strongly connected components (cycles)\n",
                "strongly_connected = disconnected_graph.get_strongly_connected_components()\n",
                "print(\"\\nStrongly connected components (cycles):\")\n",
                "for i, component in enumerate(strongly_connected, 1):\n",
                "    print(f\"  Component {i}: {component}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5. Path Finding and Analysis\n",
                "\n",
                "Let's explore path finding in more complex graphs and analyze different types of paths."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a more complex causal graph for path analysis\n",
                "path_graph = CausalGraph()\n",
                "nodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n",
                "for node in nodes:\n",
                "    path_graph.add_node(node)\n",
                "\n",
                "# Add edges to create different path options\n",
                "path_graph.add_edge('A', 'B')\n",
                "path_graph.add_edge('A', 'C')\n",
                "path_graph.add_edge('B', 'D')\n",
                "path_graph.add_edge('C', 'D')\n",
                "path_graph.add_edge('C', 'E')\n",
                "path_graph.add_edge('D', 'F')\n",
                "path_graph.add_edge('E', 'F')\n",
                "path_graph.add_edge('F', 'G')\n",
                "path_graph.add_edge('B', 'G')  # Direct but longer hop count\n",
                "\n",
                "# Visualize the path graph\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(path_graph, ax=ax, title=\"Complex Path Graph\")\n",
                "plt.show()\n",
                "\n",
                "# Find all paths between distant nodes\n",
                "all_paths = path_graph.find_all_paths('A', 'G')\n",
                "print(f\"Found {len(all_paths)} different paths from A to G:\")\n",
                "for i, path in enumerate(all_paths, 1):\n",
                "    print(f\"  Path {i}: {path} (length: {len(path)-1})\")\n",
                "\n",
                "# Find shortest path\n",
                "shortest_path = path_graph.find_shortest_path('A', 'G')\n",
                "print(f\"\\nShortest path from A to G: {shortest_path}\")\n",
                "\n",
                "# Highlight a specific path in the visualization\n",
                "highlighted_path = ['A', 'B', 'G']\n",
                "path_edges = [(highlighted_path[i], highlighted_path[i+1]) for i in range(len(highlighted_path)-1)]\n",
                "\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(path_graph, ax=ax, title=\"Graph with Highlighted Path\", \n",
                "                     highlight_edges=path_edges, highlight_nodes=highlighted_path,\n",
                "                     highlight_edge_color='red', highlight_node_color='yellow')\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Summary\n",
                "\n",
                "In this notebook, we explored the graph classes provided by the causal meta-learning library:\n",
                "\n",
                "1. The base `Graph` class provides fundamental operations for working with nodes, edges, and their attributes.\n",
                "2. The `DirectedGraph` class extends this with directed edge semantics, path finding, cycle detection, and topological sorting.\n",
                "3. The `CausalGraph` class adds causal reasoning capabilities including d-separation, Markov blanket identification, and intervention operations.\n",
                "\n",
                "These graph implementations provide a solid foundation for causal modeling, inference, and optimization tasks in the library. In the next notebooks, we'll explore graph visualization, generation, and causal environments in more detail."
            ]
        }
    ]
    # Notebook 2: Graph Visualization
    visualization_cells = [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Graph Visualization\n",
                "\n",
                "This notebook demonstrates the graph visualization capabilities of the causal meta-learning library. We'll cover:\n",
                "\n",
                "1. Basic graph visualization\n",
                "2. Customizing node and edge appearance\n",
                "3. Different layout algorithms\n",
                "4. Highlighting paths and nodes\n",
                "5. Visualizing causal graph features\n",
                "\n",
                "Let's get started!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Import necessary modules\n",
                "import sys\n",
                "import os\n",
                "\n",
                "# Add the root directory to the path to make imports work\n",
                "root_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
                "if root_dir not in sys.path:\n",
                "    sys.path.append(root_dir)\n",
                "\n",
                "# Import the graph classes and visualization module\n",
                "from causal_meta.graph import Graph, DirectedGraph, CausalGraph\n",
                "import causal_meta.graph.visualization as viz\n",
                "\n",
                "import numpy as np\n",
                "import matplotlib.pyplot as plt"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1. Basic Graph Visualization\n",
                "\n",
                "Let's start by creating and visualizing a simple directed graph."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a simple directed graph\n",
                "digraph = DirectedGraph()\n",
                "for node in ['A', 'B', 'C', 'D', 'E']:\n",
                "    digraph.add_node(node)\n",
                "\n",
                "digraph.add_edge('A', 'B')\n",
                "digraph.add_edge('A', 'C')\n",
                "digraph.add_edge('B', 'D')\n",
                "digraph.add_edge('C', 'D')\n",
                "digraph.add_edge('D', 'E')\n",
                "\n",
                "# Basic visualization\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(digraph, ax=ax, title=\"Basic Directed Graph\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2. Customizing Node and Edge Appearance\n",
                "\n",
                "Now let's customize the appearance of nodes and edges in our visualization."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Customizing node attributes\n",
                "custom_graph = DirectedGraph()\n",
                "\n",
                "# Add nodes with attributes\n",
                "custom_graph.add_node('A', color='red', size=800)\n",
                "custom_graph.add_node('B', color='blue', size=600)\n",
                "custom_graph.add_node('C', color='green', size=600)\n",
                "custom_graph.add_node('D', color='purple', size=600)\n",
                "custom_graph.add_node('E', color='orange', size=800)\n",
                "\n",
                "# Add edges with attributes\n",
                "custom_graph.add_edge('A', 'B', weight=2, style='dashed')\n",
                "custom_graph.add_edge('A', 'C', weight=1, style='solid')\n",
                "custom_graph.add_edge('B', 'D', weight=3, style='dotted')\n",
                "custom_graph.add_edge('C', 'D', weight=2, style='solid')\n",
                "custom_graph.add_edge('D', 'E', weight=4, style='solid')\n",
                "\n",
                "# Visualization with custom node colors and sizes\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(custom_graph, ax=ax, title=\"Customized Graph Appearance\",\n",
                "              node_color_attribute='color',  # Use the 'color' node attribute\n",
                "              node_size_attribute='size',    # Use the 'size' node attribute\n",
                "              edge_width_attribute='weight', # Use the 'weight' edge attribute\n",
                "              edge_style_attribute='style',  # Use the 'style' edge attribute\n",
                "              with_labels=True,              # Show node labels\n",
                "              font_size=12,                  # Set label font size\n",
                "              edge_color='gray',             # Default edge color\n",
                "              node_alpha=0.8)                # Node transparency\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3. Different Layout Algorithms\n",
                "\n",
                "The library supports various layout algorithms for positioning nodes in the visualization."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a larger graph to demonstrate layouts\n",
                "layout_graph = DirectedGraph()\n",
                "for i in range(10):\n",
                "    layout_graph.add_node(f\"Node {i}\")\n",
                "\n",
                "# Add some edges\n",
                "layout_graph.add_edge(\"Node 0\", \"Node 1\")\n",
                "layout_graph.add_edge(\"Node 0\", \"Node 2\")\n",
                "layout_graph.add_edge(\"Node 1\", \"Node 3\")\n",
                "layout_graph.add_edge(\"Node 2\", \"Node 3\")\n",
                "layout_graph.add_edge(\"Node 2\", \"Node 4\")\n",
                "layout_graph.add_edge(\"Node 3\", \"Node 5\")\n",
                "layout_graph.add_edge(\"Node 4\", \"Node 6\")\n",
                "layout_graph.add_edge(\"Node 5\", \"Node 7\")\n",
                "layout_graph.add_edge(\"Node 6\", \"Node 8\")\n",
                "layout_graph.add_edge(\"Node 7\", \"Node 9\")\n",
                "layout_graph.add_edge(\"Node 8\", \"Node 9\")\n",
                "\n",
                "# Different layout algorithms\n",
                "layouts = ['spring', 'circular', 'random', 'shell', 'spectral']\n",
                "\n",
                "# Create a grid of plots with different layouts\n",
                "fig, axes = plt.subplots(2, 3, figsize=(15, 10))\n",
                "axes = axes.flatten()\n",
                "\n",
                "for i, layout in enumerate(layouts):\n",
                "    ax = axes[i]\n",
                "    viz.plot_graph(layout_graph, ax=ax, title=f\"{layout.capitalize()} Layout\",\n",
                "                  layout=layout,\n",
                "                  with_labels=True,\n",
                "                  font_size=8,\n",
                "                  node_size=300)\n",
                "\n",
                "# Remove any unused subplots\n",
                "for j in range(len(layouts), len(axes)):\n",
                "    fig.delaxes(axes[j])\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 4. Highlighting Paths and Nodes\n",
                "\n",
                "The visualization module supports highlighting specific paths, nodes, and edges in the graph."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a medium-sized directed graph\n",
                "highlight_graph = DirectedGraph()\n",
                "for node in ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']:\n",
                "    highlight_graph.add_node(node)\n",
                "\n",
                "highlight_graph.add_edge('A', 'B')\n",
                "highlight_graph.add_edge('A', 'C')\n",
                "highlight_graph.add_edge('B', 'D')\n",
                "highlight_graph.add_edge('B', 'E')\n",
                "highlight_graph.add_edge('C', 'F')\n",
                "highlight_graph.add_edge('D', 'G')\n",
                "highlight_graph.add_edge('E', 'G')\n",
                "highlight_graph.add_edge('F', 'H')\n",
                "highlight_graph.add_edge('G', 'H')\n",
                "\n",
                "# Define a path to highlight\n",
                "path = ['A', 'B', 'E', 'G', 'H']\n",
                "path_edges = [(path[i], path[i+1]) for i in range(len(path)-1)]\n",
                "\n",
                "# Visualization with highlighted path\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(highlight_graph, ax=ax, title=\"Graph with Highlighted Path\",\n",
                "              highlight_nodes=path,                   # Nodes to highlight\n",
                "              highlight_edges=path_edges,             # Edges to highlight\n",
                "              highlight_node_color='yellow',          # Color for highlighted nodes\n",
                "              highlight_edge_color='red',             # Color for highlighted edges\n",
                "              highlight_node_size=800,                # Size for highlighted nodes\n",
                "              highlight_edge_width=3,                 # Width for highlighted edges\n",
                "              node_color='lightblue',                 # Default node color\n",
                "              edge_color='gray',                      # Default edge color\n",
                "              with_labels=True)                       # Show node labels\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5. Visualizing Causal Graph Features\n",
                "\n",
                "The `plot_causal_graph` function provides specialized visualizations for causal graphs, including highlighting d-separation, backdoor paths, and interventions."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a causal graph\n",
                "causal_graph = CausalGraph()\n",
                "for node in ['X', 'Y', 'Z1', 'Z2', 'Z3', 'M']:\n",
                "    causal_graph.add_node(node)\n",
                "\n",
                "# Add edges\n",
                "causal_graph.add_edge('X', 'M')   # Treatment -> Mediator\n",
                "causal_graph.add_edge('M', 'Y')   # Mediator -> Outcome\n",
                "causal_graph.add_edge('X', 'Y')   # Treatment -> Outcome (direct effect)\n",
                "causal_graph.add_edge('Z1', 'X')  # Confounder -> Treatment\n",
                "causal_graph.add_edge('Z1', 'Y')  # Confounder -> Outcome\n",
                "causal_graph.add_edge('Z2', 'Z1') # Upstream variable -> Confounder\n",
                "causal_graph.add_edge('Z2', 'Z3') # Common cause\n",
                "causal_graph.add_edge('Z3', 'Y')  # Another path to outcome\n",
                "\n",
                "# Basic causal graph visualization\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(causal_graph, ax=ax, title=\"Causal Graph with Confounders and Mediators\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Highlighting backdoor paths"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Find backdoor paths from X to Y\n",
                "backdoor_paths = causal_graph.get_backdoor_paths('X', 'Y')\n",
                "print(\"Backdoor paths from X to Y:\")\n",
                "for i, path in enumerate(backdoor_paths):\n",
                "    print(f\"  Path {i+1}: {path}\")\n",
                "\n",
                "# Highlight the first backdoor path\n",
                "if backdoor_paths:\n",
                "    backdoor_path = backdoor_paths[0]\n",
                "    # Create edge pairs from the path\n",
                "    backdoor_edges = [(backdoor_path[i], backdoor_path[i+1]) for i in range(len(backdoor_path)-1)]\n",
                "    \n",
                "    plt.figure(figsize=(10, 6))\n",
                "    ax = plt.gca()\n",
                "    viz.plot_causal_graph(\n",
                "        causal_graph, ax=ax, \n",
                "        title=f\"Causal Graph with Highlighted Backdoor Path: {' → '.join(backdoor_path)}\",\n",
                "        highlight_nodes=backdoor_path,\n",
                "        highlight_edges=backdoor_edges,\n",
                "        highlight_node_color='orange',\n",
                "        highlight_edge_color='red',\n",
                "        node_color='lightblue'\n",
                "    )\n",
                "    plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Visualizing d-separation"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Visualizing d-separation with conditioning set\n",
                "conditioning_set = {'Z1'}\n",
                "\n",
                "# Check if X and Y are d-separated given Z1\n",
                "is_separated = causal_graph.is_d_separated('X', 'Y', conditioning_set)\n",
                "print(f\"Are X and Y d-separated given {conditioning_set}? {is_separated}\")\n",
                "\n",
                "# Visualize with highlighted conditioning set\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(\n",
                "    causal_graph, ax=ax,\n",
                "    title=f\"D-separation: X and Y given {conditioning_set} ({is_separated})\",\n",
                "    highlight_nodes=['X', 'Y'] + list(conditioning_set),\n",
                "    highlight_node_color=['red', 'blue', 'green'],  # X, Y, Z1\n",
                "    highlight_node_size=[600, 600, 800]             # X, Y, Z1\n",
                ")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Visualizing interventions"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create an intervened graph\n",
                "intervened_graph = causal_graph.do_intervention('X')\n",
                "\n",
                "# Side-by-side visualization of original and intervened graphs\n",
                "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 7))\n",
                "\n",
                "# Original graph\n",
                "viz.plot_causal_graph(causal_graph, ax=ax1, title=\"Original Causal Graph\")\n",
                "\n",
                "# Intervened graph with highlighted intervention\n",
                "viz.plot_causal_graph(\n",
                "    intervened_graph, ax=ax2,\n",
                "    title=\"Causal Graph after do(X)\",\n",
                "    highlight_nodes=['X'],\n",
                "    highlight_node_color='red',\n",
                "    highlight_node_size=800\n",
                ")\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Visualizing different causal structures"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create common causal structures for visualization\n",
                "structures = []\n",
                "\n",
                "# Chain: X -> Z -> Y\n",
                "chain = CausalGraph()\n",
                "for node in ['X', 'Z', 'Y']:\n",
                "    chain.add_node(node)\n",
                "chain.add_edge('X', 'Z')\n",
                "chain.add_edge('Z', 'Y')\n",
                "structures.append((chain, \"Chain (X → Z → Y)\"))\n",
                "\n",
                "# Fork: X <- Z -> Y\n",
                "fork = CausalGraph()\n",
                "for node in ['X', 'Z', 'Y']:\n",
                "    fork.add_node(node)\n",
                "fork.add_edge('Z', 'X')\n",
                "fork.add_edge('Z', 'Y')\n",
                "structures.append((fork, \"Fork (X ← Z → Y)\"))\n",
                "\n",
                "# Collider: X -> Z <- Y\n",
                "collider = CausalGraph()\n",
                "for node in ['X', 'Z', 'Y']:\n",
                "    collider.add_node(node)\n",
                "collider.add_edge('X', 'Z')\n",
                "collider.add_edge('Y', 'Z')\n",
                "structures.append((collider, \"Collider (X → Z ← Y)\"))\n",
                "\n",
                "# Create a grid of plots for different structures\n",
                "fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
                "\n",
                "for i, (graph, title) in enumerate(structures):\n",
                "    ax = axes[i]\n",
                "    viz.plot_causal_graph(graph, ax=ax, title=title,\n",
                "                         node_size=1000,\n",
                "                         node_color='lightblue',\n",
                "                         edge_color='black',\n",
                "                         font_size=14,\n",
                "                         with_labels=True)\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Advanced Visualization Techniques\n",
                "\n",
                "Let's explore some more advanced visualization features."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a more complex causal graph for visualization\n",
                "complex_causal = CausalGraph()\n",
                "\n",
                "# Add nodes with type attributes\n",
                "nodes = {\n",
                "    'A': 'treatment',\n",
                "    'B': 'mediator',\n",
                "    'C': 'mediator',\n",
                "    'D': 'outcome',\n",
                "    'E': 'confounder',\n",
                "    'F': 'instrumental',\n",
                "    'G': 'proxy'\n",
                "}\n",
                "\n",
                "for node, node_type in nodes.items():\n",
                "    complex_causal.add_node(node, type=node_type)\n",
                "\n",
                "# Add edges with strength attributes\n",
                "edges = [\n",
                "    ('F', 'A', 0.8),  # Instrumental -> Treatment\n",
                "    ('A', 'B', 0.6),  # Treatment -> Mediator\n",
                "    ('A', 'C', 0.4),  # Treatment -> Mediator\n",
                "    ('B', 'D', 0.7),  # Mediator -> Outcome\n",
                "    ('C', 'D', 0.5),  # Mediator -> Outcome\n",
                "    ('E', 'A', 0.3),  # Confounder -> Treatment\n",
                "    ('E', 'D', 0.4),  # Confounder -> Outcome\n",
                "    ('G', 'E', 0.2),  # Proxy -> Confounder\n",
                "]\n",
                "\n",
                "for source, target, strength in edges:\n",
                "    complex_causal.add_edge(source, target, strength=strength)\n",
                "\n",
                "# Define color mapping for node types\n",
                "type_colors = {\n",
                "    'treatment': 'red',\n",
                "    'mediator': 'green',\n",
                "    'outcome': 'blue',\n",
                "    'confounder': 'purple',\n",
                "    'instrumental': 'orange',\n",
                "    'proxy': 'brown'\n",
                "}\n",
                "\n",
                "# Custom node coloring function\n",
                "def color_by_type(n, graph):\n",
                "    node_type = graph.get_node_attributes(n).get('type', 'default')\n",
                "    return type_colors.get(node_type, 'gray')\n",
                "\n",
                "# Custom edge width function\n",
                "def width_by_strength(u, v, graph):\n",
                "    return graph.get_edge_attributes(u, v).get('strength', 0.5) * 5\n",
                "\n",
                "# Visualize with custom coloring and edge width functions\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(\n",
                "    complex_causal, ax=ax,\n",
                "    title=\"Complex Causal Graph with Type-Based Coloring and Edge Strengths\",\n",
                "    node_color_func=color_by_type,\n",
                "    edge_width_func=width_by_strength,\n",
                "    with_labels=True,\n",
                "    font_size=12,\n",
                "    node_size=800\n",
                ")\n",
                "\n",
                "# Add a legend for node types\n",
                "legend_elements = [plt.Line2D([0], [0], marker='o', color='w', label=t.capitalize(),\n",
                "                             markerfacecolor=c, markersize=10) \n",
                "                  for t, c in type_colors.items()]\n",
                "ax.legend(handles=legend_elements, title=\"Node Types\", loc=\"upper right\")\n",
                "\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Summary\n",
                "\n",
                "In this notebook, we explored the graph visualization capabilities of the causal meta-learning library:\n",
                "\n",
                "1. Basic graph visualization with `plot_graph` and `plot_causal_graph` functions\n",
                "2. Customizing node and edge appearance based on attributes\n",
                "3. Different layout algorithms for node positioning\n",
                "4. Highlighting paths, nodes, and edges for emphasis\n",
                "5. Specialized causal graph visualizations for d-separation, backdoor paths, and interventions\n",
                "6. Advanced customization with color and size mapping functions\n",
                "\n",
                "These visualization capabilities are essential for understanding and communicating graph structures and causal relationships in the library."
            ]
        }
    ]
    # Notebook 3: Graph Generation
    generation_cells = [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Graph Generation\n",
                "\n",
                "This notebook demonstrates how to use the graph generation factory pattern to create different types of graphs. We'll cover:\n",
                "\n",
                "1. Using the GraphFactory class\n",
                "2. Creating random graphs\n",
                "3. Generating scale-free networks\n",
                "4. Creating predefined graph structures\n",
                "5. Customizing graph generation parameters\n",
                "\n",
                "Let's get started!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Import necessary modules\n",
                "import sys\n",
                "import os\n",
                "\n",
                "# Add the root directory to the path to make imports work\n",
                "root_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
                "if root_dir not in sys.path:\n",
                "    sys.path.append(root_dir)\n",
                "\n",
                "# Import the necessary modules\n",
                "from causal_meta.graph import CausalGraph, DirectedGraph\n",
                "from causal_meta.graph.generators.factory import GraphFactory\n",
                "import causal_meta.graph.visualization as viz\n",
                "\n",
                "import numpy as np\n",
                "import matplotlib.pyplot as plt"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1. Using the GraphFactory class\n",
                "\n",
                "The `GraphFactory` class provides a unified interface for creating different types of graphs, following the factory pattern design principle."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create an instance of the GraphFactory\n",
                "factory = GraphFactory()\n",
                "\n",
                "# Display available graph types\n",
                "print(\"Available graph types:\")\n",
                "for graph_type in factory.available_graph_types():\n",
                "    print(f\"  - {graph_type}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2. Creating Random Graphs\n",
                "\n",
                "The factory can generate random graphs using the Erdős–Rényi model, where edges are added with a specified probability."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a random directed graph\n",
                "random_graph = factory.create_graph(\n",
                "    graph_type=\"random\",\n",
                "    num_nodes=10,\n",
                "    edge_probability=0.3,\n",
                "    directed=True,\n",
                "    seed=42  # For reproducibility\n",
                ")\n",
                "\n",
                "# Print some basic stats\n",
                "print(f\"Random graph nodes: {len(random_graph.get_nodes())}\")\n",
                "print(f\"Random graph edges: {len(random_graph.get_edges())}\")\n",
                "print(f\"Expected number of edges: {10 * 9 * 0.3:.1f}\")\n",
                "\n",
                "# Visualize the random graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(random_graph, ax=ax, title=\"Random Directed Graph (Erdős–Rényi, p=0.3)\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Varying edge probability in random graphs\n",
                "\n",
                "Let's see how varying the edge probability affects the structure of random graphs."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create random graphs with different edge probabilities\n",
                "probabilities = [0.1, 0.3, 0.5, 0.8]\n",
                "random_graphs = []\n",
                "\n",
                "for p in probabilities:\n",
                "    graph = factory.create_graph(\n",
                "        graph_type=\"random\",\n",
                "        num_nodes=10,\n",
                "        edge_probability=p,\n",
                "        directed=True,\n",
                "        seed=42  # Use the same seed for fair comparison\n",
                "    )\n",
                "    random_graphs.append((graph, f\"p={p}\"))\n",
                "\n",
                "# Create a grid of visualizations\n",
                "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
                "axes = axes.flatten()\n",
                "\n",
                "for i, (graph, title) in enumerate(random_graphs):\n",
                "    ax = axes[i]\n",
                "    edge_count = len(graph.get_edges())\n",
                "    viz.plot_graph(graph, ax=ax, \n",
                "                  title=f\"Random Graph with {title} ({edge_count} edges)\")\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3. Generating Scale-Free Networks\n",
                "\n",
                "Scale-free networks are characterized by a power-law degree distribution, where a few nodes have many connections (hubs) and most nodes have few connections."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a scale-free network using the Barabási-Albert model\n",
                "scale_free_graph = factory.create_graph(\n",
                "    graph_type=\"scale_free\",\n",
                "    num_nodes=50,\n",
                "    m=2,  # Number of edges to attach from a new node to existing nodes\n",
                "    directed=True,  # Create a directed graph\n",
                "    seed=42  # For reproducibility\n",
                ")\n",
                "\n",
                "# Print basic stats\n",
                "print(f\"Scale-free graph nodes: {len(scale_free_graph.get_nodes())}\")\n",
                "print(f\"Scale-free graph edges: {len(scale_free_graph.get_edges())}\")\n",
                "\n",
                "# Visualize the scale-free network\n",
                "plt.figure(figsize=(12, 8))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(scale_free_graph, ax=ax, \n",
                "              title=\"Scale-Free Network (Barabási-Albert, m=2)\",\n",
                "              layout=\"spring\",  # Use spring layout to better show the hub structure\n",
                "              node_size=200)\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Analyzing the degree distribution of scale-free networks\n",
                "\n",
                "One key characteristic of scale-free networks is their power-law degree distribution. Let's verify this property."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a larger scale-free network for better statistical analysis\n",
                "large_scale_free = factory.create_graph(\n",
                "    graph_type=\"scale_free\",\n",
                "    num_nodes=500,\n",
                "    m=2,\n",
                "    directed=False,  # Use undirected for simpler degree analysis\n",
                "    seed=42\n",
                ")\n",
                "\n",
                "# Calculate the degree of each node\n",
                "degrees = [len(large_scale_free.get_neighbors(node)) for node in large_scale_free.get_nodes()]\n",
                "\n",
                "# Count the frequency of each degree\n",
                "degree_count = {}\n",
                "for degree in degrees:\n",
                "    degree_count[degree] = degree_count.get(degree, 0) + 1\n",
                "\n",
                "# Convert to lists for plotting\n",
                "x = list(degree_count.keys())\n",
                "y = list(degree_count.values())\n",
                "\n",
                "# Plot the degree distribution\n",
                "plt.figure(figsize=(10, 6))\n",
                "plt.loglog(x, y, 'o', markersize=8)\n",
                "plt.grid(True, which=\"both\", ls=\"-\")\n",
                "plt.xlabel('Degree (log scale)')\n",
                "plt.ylabel('Frequency (log scale)')\n",
                "plt.title('Degree Distribution of Scale-Free Network (log-log scale)')\n",
                "\n",
                "# Add a trend line to visualize the power law\n",
                "from scipy import stats\n",
                "# Filter out degrees with zero count to avoid log(0)\n",
                "x_log = np.log(x)\n",
                "y_log = np.log(y)\n",
                "slope, intercept, r_value, p_value, std_err = stats.linregress(x_log, y_log)\n",
                "\n",
                "# Plot the best fit line\n",
                "x_line = np.array([min(x), max(x)])\n",
                "y_line = np.exp(intercept) * x_line**slope\n",
                "plt.loglog(x_line, y_line, 'r-', linewidth=2, \n",
                "           label=f'Power law fit: γ = {-slope:.2f}')\n",
                "plt.legend()\n",
                "plt.show()\n",
                "\n",
                "print(f\"Power law exponent (γ): {-slope:.2f}\")\n",
                "print(f\"R-squared value: {r_value**2:.2f}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 4. Creating Predefined Graph Structures\n",
                "\n",
                "The factory can also create common predefined graph structures, such as chains, trees, and complete graphs."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create various predefined graph structures\n",
                "predefined_graphs = []\n",
                "\n",
                "# Chain graph (linear path)\n",
                "chain_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"chain\",\n",
                "    num_nodes=5,\n",
                "    directed=True\n",
                ")\n",
                "predefined_graphs.append((chain_graph, \"Chain Graph\"))\n",
                "\n",
                "# Tree graph\n",
                "tree_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"tree\",\n",
                "    num_nodes=10,\n",
                "    branching_factor=2,  # Binary tree\n",
                "    directed=True\n",
                ")\n",
                "predefined_graphs.append((tree_graph, \"Binary Tree Graph\"))\n",
                "\n",
                "# Complete graph (every node connected to every other node)\n",
                "complete_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"complete\",\n",
                "    num_nodes=6,\n",
                "    directed=True\n",
                ")\n",
                "predefined_graphs.append((complete_graph, \"Complete Graph\"))\n",
                "\n",
                "# Bipartite graph\n",
                "bipartite_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"bipartite\",\n",
                "    n1=4,  # Nodes in first set\n",
                "    n2=3,  # Nodes in second set\n",
                "    edge_probability=0.5,\n",
                "    directed=True,\n",
                "    seed=42\n",
                ")\n",
                "predefined_graphs.append((bipartite_graph, \"Bipartite Graph\"))\n",
                "\n",
                "# Create a grid of visualizations\n",
                "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
                "axes = axes.flatten()\n",
                "\n",
                "for i, (graph, title) in enumerate(predefined_graphs):\n",
                "    ax = axes[i]\n",
                "    viz.plot_graph(graph, ax=ax, title=title)\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Causal graph structures\n",
                "\n",
                "The factory can also create common causal graph structures for causal inference experiments."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create common causal graph structures\n",
                "causal_graphs = []\n",
                "\n",
                "# Fork structure (X ← Z → Y)\n",
                "fork_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"fork\",\n",
                "    labels=['X', 'Z', 'Y'],\n",
                "    directed=True\n",
                ")\n",
                "causal_graphs.append((fork_graph, \"Fork (X ← Z → Y)\"))\n",
                "\n",
                "# Collider structure (X → Z ← Y)\n",
                "collider_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"collider\",\n",
                "    labels=['X', 'Z', 'Y'],\n",
                "    directed=True\n",
                ")\n",
                "causal_graphs.append((collider_graph, \"Collider (X → Z ← Y)\"))\n",
                "\n",
                "# Chain/Mediator structure (X → Z → Y)\n",
                "chain_causal_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"chain\",\n",
                "    labels=['X', 'Z', 'Y'],\n",
                "    directed=True\n",
                ")\n",
                "causal_graphs.append((chain_causal_graph, \"Chain/Mediator (X → Z → Y)\"))\n",
                "\n",
                "# Create a grid of visualizations\n",
                "fig, axes = plt.subplots(1, 3, figsize=(18, 6))\n",
                "axes = axes.flatten()\n",
                "\n",
                "for i, (graph, title) in enumerate(causal_graphs):\n",
                "    ax = axes[i]\n",
                "    viz.plot_causal_graph(graph, ax=ax, title=title,\n",
                "                        node_size=1000,\n",
                "                        node_color='lightblue',\n",
                "                        font_size=14)\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5. Customizing Graph Generation Parameters\n",
                "\n",
                "The factory allows extensive customization of the generated graphs."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a custom graph from an adjacency matrix\n",
                "# Define an adjacency matrix representing a specific graph structure\n",
                "adj_matrix = np.array([\n",
                "    [0, 1, 1, 0, 0],\n",
                "    [0, 0, 1, 1, 0],\n",
                "    [0, 0, 0, 1, 1],\n",
                "    [0, 0, 0, 0, 1],\n",
                "    [0, 0, 0, 0, 0]\n",
                "])\n",
                "\n",
                "# Create graph from adjacency matrix\n",
                "custom_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"from_adjacency\",\n",
                "    adjacency_matrix=adj_matrix,\n",
                "    directed=True,\n",
                "    labels=['A', 'B', 'C', 'D', 'E']\n",
                ")\n",
                "\n",
                "# Visualize the custom graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_graph(custom_graph, ax=ax, title=\"Custom Graph from Adjacency Matrix\")\n",
                "plt.show()\n",
                "\n",
                "# Display the adjacency matrix\n",
                "plt.figure(figsize=(8, 6))\n",
                "plt.imshow(adj_matrix, cmap='Blues')\n",
                "plt.colorbar(label='Edge presence')\n",
                "plt.title('Adjacency Matrix of Custom Graph')\n",
                "plt.xticks(range(5), ['A', 'B', 'C', 'D', 'E'])\n",
                "plt.yticks(range(5), ['A', 'B', 'C', 'D', 'E'])\n",
                "plt.grid(False)\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Adding noise to predefined structures\n",
                "\n",
                "The factory allows adding random noise (additional edges) to predefined structures, which can be useful for testing algorithm robustness."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a tree graph with different levels of random noise\n",
                "noise_levels = [0.0, 0.05, 0.1, 0.2]\n",
                "noisy_graphs = []\n",
                "\n",
                "for noise in noise_levels:\n",
                "    graph = factory.create_graph(\n",
                "        graph_type=\"predefined\",\n",
                "        structure=\"tree\",\n",
                "        num_nodes=10,\n",
                "        branching_factor=2,\n",
                "        directed=True,\n",
                "        noise_edges=noise,  # Probability of adding random edges\n",
                "        seed=42  # Same seed for fair comparison\n",
                "    )\n",
                "    noisy_graphs.append((graph, f\"Noise: {noise:.2f}\"))\n",
                "\n",
                "# Create a grid of visualizations\n",
                "fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
                "axes = axes.flatten()\n",
                "\n",
                "for i, (graph, title) in enumerate(noisy_graphs):\n",
                "    ax = axes[i]\n",
                "    edge_count = len(graph.get_edges())\n",
                "    base_edges = 9  # A binary tree with 10 nodes has 9 edges\n",
                "    extra_edges = edge_count - base_edges\n",
                "    viz.plot_graph(graph, ax=ax, \n",
                "                  title=f\"Tree with {title} (+{extra_edges} edges)\")\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 6. Generating Task Families for Meta-Learning\n",
                "\n",
                "For meta-learning applications, we often need to generate families of related graphs with controlled variations. Let's see how to create a task family based on a seed graph."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a seed graph (a simple DAG)\n",
                "seed_graph = factory.create_graph(\n",
                "    graph_type=\"predefined\",\n",
                "    structure=\"from_adjacency\",\n",
                "    adjacency_matrix=np.array([\n",
                "        [0, 1, 1, 0, 0],\n",
                "        [0, 0, 0, 1, 0],\n",
                "        [0, 0, 0, 1, 1],\n",
                "        [0, 0, 0, 0, 1],\n",
                "        [0, 0, 0, 0, 0]\n",
                "    ]),\n",
                "    directed=True\n",
                ")\n",
                "\n",
                "# Generate a family of related graphs by perturbing the seed graph\n",
                "num_variations = 5\n",
                "edge_perturbation_prob = 0.2\n",
                "task_family = factory.create_task_family(\n",
                "    seed_graph=seed_graph,\n",
                "    num_graphs=num_variations,\n",
                "    edge_perturbation_prob=edge_perturbation_prob,\n",
                "    seed=42\n",
                ")\n",
                "\n",
                "# Visualize the seed graph and its variations\n",
                "fig, axes = plt.subplots(2, 3, figsize=(18, 12))\n",
                "axes = axes.flatten()\n",
                "\n",
                "# Visualize the seed graph\n",
                "viz.plot_graph(seed_graph, ax=axes[0], title=\"Seed Graph\")\n",
                "\n",
                "# Visualize the variations\n",
                "for i, graph in enumerate(task_family):\n",
                "    ax = axes[i+1]\n",
                "    viz.plot_graph(graph, ax=ax, title=f\"Variation {i+1}\")\n",
                "    \n",
                "    # Compare with the seed graph\n",
                "    seed_edges = seed_graph.get_edges()\n",
                "    var_edges = graph.get_edges()\n",
                "    added = len(var_edges - seed_edges)\n",
                "    removed = len(seed_edges - var_edges)\n",
                "    ax.set_xlabel(f\"Added: {added}, Removed: {removed}\")\n",
                "\n",
                "# Remove any unused subplots\n",
                "for j in range(1 + len(task_family), len(axes)):\n",
                "    fig.delaxes(axes[j])\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Summary\n",
                "\n",
                "In this notebook, we explored the graph generation capabilities of the causal meta-learning library using the factory pattern:\n",
                "\n",
                "1. The `GraphFactory` class provides a unified interface for creating different types of graphs\n",
                "2. Random graphs can be generated with configurable edge probabilities\n",
                "3. Scale-free networks exhibit power-law degree distributions with hub nodes\n",
                "4. Predefined graph structures include chains, trees, complete graphs, and common causal structures\n",
                "5. Graphs can be customized with various parameters including noise, adjacency matrices, and node labels\n",
                "6. Task families can be generated for meta-learning applications\n",
                "\n",
                "These generation capabilities are essential for creating synthetic datasets for testing algorithms, conducting simulation studies, and developing meta-learning approaches to causal inference and optimization."
            ]
        }
    ]
    # Notebook 4: Structural Causal Models
    scm_cells = [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Structural Causal Models\n",
                "\n",
                "This notebook demonstrates how to work with Structural Causal Models (SCMs) in the causal meta-learning library. We'll cover:\n",
                "\n",
                "1. Creating and defining SCMs\n",
                "2. Defining structural equations and mechanisms\n",
                "3. Sampling data from SCMs\n",
                "4. Performing interventions\n",
                "5. Calculating causal effects\n",
                "\n",
                "Let's get started!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Import necessary modules\n",
                "import sys\n",
                "import os\n",
                "\n",
                "# Add the root directory to the path to make imports work\n",
                "root_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
                "if root_dir not in sys.path:\n",
                "    sys.path.append(root_dir)\n",
                "\n",
                "# Import the necessary modules\n",
                "from causal_meta.graph import CausalGraph\n",
                "from causal_meta.environments.scm import StructuralCausalModel\n",
                "import causal_meta.graph.visualization as viz\n",
                "\n",
                "import numpy as np\n",
                "import pandas as pd\n",
                "import matplotlib.pyplot as plt\n",
                "import seaborn as sns"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1. Creating and Defining SCMs\n",
                "\n",
                "A Structural Causal Model (SCM) represents a system of causal relationships where each variable is determined by a function of its parent variables and some independent noise. Let's create a simple SCM."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a causal graph for our SCM\n",
                "graph = CausalGraph()\n",
                "\n",
                "# Add nodes\n",
                "graph.add_node('X')\n",
                "graph.add_node('Y')\n",
                "graph.add_node('Z')\n",
                "\n",
                "# Add edges to define the causal structure\n",
                "graph.add_edge('X', 'Y')  # X causes Y\n",
                "graph.add_edge('Z', 'X')  # Z causes X\n",
                "graph.add_edge('Z', 'Y')  # Z causes Y (directly)\n",
                "\n",
                "# Visualize the graph\n",
                "plt.figure(figsize=(8, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(graph, ax=ax, title=\"Causal Graph for our SCM\")\n",
                "plt.show()\n",
                "\n",
                "# Create the SCM with this causal graph\n",
                "scm = StructuralCausalModel(causal_graph=graph)\n",
                "\n",
                "# Add variables with domains\n",
                "scm.add_variable('X', domain='continuous')\n",
                "scm.add_variable('Y', domain='continuous')\n",
                "scm.add_variable('Z', domain='continuous')"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2. Defining Structural Equations and Mechanisms\n",
                "\n",
                "Now we need to define the structural equations that determine how each variable is influenced by its parents."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Define linear Gaussian structural equations\n",
                "\n",
                "# Z is an exogenous variable (no parents)\n",
                "scm.define_linear_gaussian_equation('Z', {}, intercept=0, noise_std=1.0)\n",
                "\n",
                "# X depends on Z\n",
                "scm.define_linear_gaussian_equation('X', {'Z': 0.7}, intercept=0, noise_std=0.5)\n",
                "\n",
                "# Y depends on both X and Z\n",
                "scm.define_linear_gaussian_equation('Y', {'X': 0.6, 'Z': 0.3}, intercept=0, noise_std=0.3)\n",
                "\n",
                "# Inspect the SCM\n",
                "print(scm)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Using Custom Structural Equations\n",
                "\n",
                "We can also define custom non-linear equations for more complex relationships."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create a new SCM with non-linear relationships\n",
                "nonlinear_graph = CausalGraph()\n",
                "for node in ['X', 'Y']:\n",
                "    nonlinear_graph.add_node(node)\n",
                "nonlinear_graph.add_edge('X', 'Y')\n",
                "\n",
                "nonlinear_scm = StructuralCausalModel(causal_graph=nonlinear_graph)\n",
                "nonlinear_scm.add_variable('X', domain='continuous')\n",
                "nonlinear_scm.add_variable('Y', domain='continuous')\n",
                "\n",
                "# X is exogenous with standard normal distribution\n",
                "def x_equation(noise):\n",
                "    return noise\n",
                "\n",
                "# Y is a non-linear function of X (quadratic with noise)\n",
                "def y_equation(X, noise):\n",
                "    return 0.5 * (X ** 2) - 0.3 * X + noise\n",
                "\n",
                "# Define noise distributions\n",
                "def normal_noise(rng):\n",
                "    return rng.normal(0, 1)\n",
                "\n",
                "# Define the structural equations\n",
                "nonlinear_scm.define_probabilistic_equation('X', x_equation, normal_noise)\n",
                "nonlinear_scm.define_probabilistic_equation('Y', y_equation, lambda rng: rng.normal(0, 0.5))\n",
                "\n",
                "print(nonlinear_scm)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3. Sampling Data from SCMs\n",
                "\n",
                "Once we've defined our structural equations, we can sample data from the SCM."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Sample data from our linear SCM\n",
                "data = scm.sample_data(1000, random_seed=42)\n",
                "\n",
                "# Display the first few rows\n",
                "print(\"Data from linear SCM:\")\n",
                "print(data.head())\n",
                "\n",
                "# Calculate the correlations\n",
                "print(\"\\nCorrelation matrix:\")\n",
                "print(data.corr().round(3))\n",
                "\n",
                "# Visualize the relationships with a pairplot\n",
                "plt.figure(figsize=(12, 10))\n",
                "sns.pairplot(data)\n",
                "plt.suptitle(\"Relationships between variables\", y=1.02)\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Sample data from the non-linear SCM\n",
                "nonlinear_data = nonlinear_scm.sample_data(1000, random_seed=42)\n",
                "\n",
                "# Display the first few rows\n",
                "print(\"Data from non-linear SCM:\")\n",
                "print(nonlinear_data.head())\n",
                "\n",
                "# Visualize the non-linear relationship\n",
                "plt.figure(figsize=(10, 6))\n",
                "plt.scatter(nonlinear_data['X'], nonlinear_data['Y'], alpha=0.5)\n",
                "plt.title(\"Non-linear Relationship: Y = 0.5X² - 0.3X + ε\")\n",
                "plt.xlabel(\"X\")\n",
                "plt.ylabel(\"Y\")\n",
                "plt.grid(True)\n",
                "\n",
                "# Add the true functional relationship line\n",
                "x_range = np.linspace(-3, 3, 100)\n",
                "plt.plot(x_range, 0.5 * (x_range ** 2) - 0.3 * x_range, 'r-', label=\"True function\")\n",
                "plt.legend()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 4. Performing Interventions\n",
                "\n",
                "One of the key features of SCMs is the ability to perform interventions, which allow us to model counterfactual scenarios."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Let's perform an intervention on X in our linear SCM\n",
                "scm.do_intervention('X', 2.0)  # Set X to a fixed value\n",
                "\n",
                "# Sample data under the intervention\n",
                "interventional_data = scm.sample_data(1000, random_seed=42)\n",
                "\n",
                "# Display the first few rows\n",
                "print(\"Interventional data with do(X=2.0):\")\n",
                "print(interventional_data.head())\n",
                "\n",
                "# Verify X has been fixed to 2.0\n",
                "print(f\"\\nMean of X: {interventional_data['X'].mean():.5f}\")\n",
                "print(f\"Standard deviation of X: {interventional_data['X'].std():.5f}\")\n",
                "\n",
                "# Reset the SCM to remove the intervention\n",
                "scm.reset()\n",
                "\n",
                "# Compare with observational data\n",
                "fig, axes = plt.subplots(1, 2, figsize=(16, 6))\n",
                "\n",
                "# Observational data\n",
                "axes[0].scatter(data['X'], data['Y'], alpha=0.5)\n",
                "axes[0].set_title(\"Observational Data\")\n",
                "axes[0].set_xlabel(\"X\")\n",
                "axes[0].set_ylabel(\"Y\")\n",
                "axes[0].grid(True)\n",
                "\n",
                "# Interventional data\n",
                "axes[1].scatter(interventional_data['X'], interventional_data['Y'], alpha=0.5)\n",
                "axes[1].set_title(\"Interventional Data with do(X=2.0)\")\n",
                "axes[1].set_xlabel(\"X\")\n",
                "axes[1].set_ylabel(\"Y\")\n",
                "axes[1].grid(True)\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Multiple Interventions\n",
                "\n",
                "We can also perform multiple interventions simultaneously."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Perform multiple interventions\n",
                "scm.multiple_interventions({'X': 1.0, 'Z': -1.0})  # Set X=1.0 and Z=-1.0\n",
                "\n",
                "# Sample data under the multiple interventions\n",
                "multi_interventional_data = scm.sample_data(1000, random_seed=42)\n",
                "\n",
                "# Display the first few rows\n",
                "print(\"Data with do(X=1.0, Z=-1.0):\")\n",
                "print(multi_interventional_data.head())\n",
                "\n",
                "# Verify X and Z have been fixed\n",
                "print(f\"\\nMean of X: {multi_interventional_data['X'].mean():.5f}\")\n",
                "print(f\"Mean of Z: {multi_interventional_data['Z'].mean():.5f}\")\n",
                "\n",
                "# Reset the SCM to remove the interventions\n",
                "scm.reset()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5. Calculating Causal Effects\n",
                "\n",
                "SCMs allow us to estimate causal effects by measuring how changes in one variable affect another."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Calculate the average causal effect of X on Y\n",
                "effect = scm.compute_effect(treatment='X', outcome='Y', \n",
                "                          treatment_value=1.0, baseline_value=0.0,\n",
                "                          sample_size=5000, random_seed=42)\n",
                "\n",
                "print(f\"Average Causal Effect of X on Y (when X changes from 0 to 1): {effect:.4f}\")\n",
                "\n",
                "# This should be close to the coefficient 0.6 that we used in the structural equation\n",
                "print(f\"True coefficient in the structural equation: 0.6\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Direct and Indirect Effects\n",
                "\n",
                "We can also decompose the total causal effect into direct and indirect components."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Calculate the direct effect of Z on Y\n",
                "direct_effect = scm.compute_direct_effect(\n",
                "    treatment='Z', outcome='Y', \n",
                "    treatment_value=1.0, baseline_value=0.0,\n",
                "    sample_size=5000, random_seed=42\n",
                ")\n",
                "\n",
                "print(f\"Direct Effect of Z on Y: {direct_effect:.4f}\")\n",
                "print(f\"True direct effect in the structural equation: 0.3\")\n",
                "\n",
                "# Calculate the indirect effect of Z on Y through X\n",
                "indirect_effect = scm.compute_indirect_effect(\n",
                "    treatment='Z', outcome='Y', \n",
                "    treatment_value=1.0, baseline_value=0.0,\n",
                "    mediators=['X'],  # X is the mediator \n",
                "    sample_size=5000, random_seed=42\n",
                ")\n",
                "\n",
                "print(f\"\\nIndirect Effect of Z on Y through X: {indirect_effect:.4f}\")\n",
                "print(f\"Expected indirect effect: Z→X coefficient × X→Y coefficient = 0.7 × 0.6 = 0.42\")\n",
                "\n",
                "# Calculate total effect\n",
                "total_effect = scm.compute_effect(\n",
                "    treatment='Z', outcome='Y', \n",
                "    treatment_value=1.0, baseline_value=0.0,\n",
                "    sample_size=5000, random_seed=42\n",
                ")\n",
                "\n",
                "print(f\"\\nTotal Effect of Z on Y: {total_effect:.4f}\")\n",
                "print(f\"Direct + Indirect Effect: {direct_effect + indirect_effect:.4f}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Visualizing Intervention Effects\n",
                "\n",
                "Let's visualize how interventions on a variable affect the distribution of an outcome."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Get intervention effects for a range of intervention values\n",
                "treatment = 'X'\n",
                "outcome = 'Y'\n",
                "intervention_values = np.linspace(-2, 2, 9)  # Intervention values from -2 to 2\n",
                "\n",
                "# Get the distribution of Y under each intervention\n",
                "all_data = []\n",
                "distributions = []\n",
                "\n",
                "for value in intervention_values:\n",
                "    # Perform intervention\n",
                "    scm.do_intervention(treatment, value)\n",
                "    \n",
                "    # Sample data\n",
                "    int_data = scm.sample_data(1000, random_seed=42)\n",
                "    \n",
                "    # Store the distribution of Y\n",
                "    distributions.append(int_data[outcome].values)\n",
                "    \n",
                "    # Add intervention value for plotting\n",
                "    int_data['Intervention'] = f\"{treatment}={value:.1f}\"\n",
                "    all_data.append(int_data)\n",
                "    \n",
                "    # Reset SCM\n",
                "    scm.reset()\n",
                "\n",
                "# Combine all data\n",
                "combined_data = pd.concat(all_data)\n",
                "\n",
                "# Create a boxplot to compare Y distributions across interventions\n",
                "plt.figure(figsize=(12, 6))\n",
                "sns.boxplot(x='Intervention', y=outcome, data=combined_data)\n",
                "plt.title(f\"Distribution of {outcome} under different interventions on {treatment}\")\n",
                "plt.xlabel(f\"Intervention on {treatment}\")\n",
                "plt.ylabel(outcome)\n",
                "plt.grid(True, axis='y')\n",
                "plt.xticks(rotation=45)\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Counterfactual Analysis\n",
                "\n",
                "SCMs also allow us to reason about counterfactuals - what would have happened in a specific case if we had intervened differently."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Generate a \"factual\" observation\n",
                "scm.reset()\n",
                "factual_data = scm.sample_data(1, random_seed=42)\n",
                "print(\"Factual observation:\")\n",
                "print(factual_data)\n",
                "\n",
                "# Perform counterfactual reasoning: what would Y have been if X was set to 2.0?\n",
                "counterfactual_data = scm.evaluate_counterfactual(\n",
                "    factual_data=factual_data, \n",
                "    interventions={'X': 2.0}\n",
                ")\n",
                "\n",
                "print(\"\\nCounterfactual scenario (do(X=2.0)):\")\n",
                "print(counterfactual_data)\n",
                "\n",
                "# Calculate the difference in Y\n",
                "y_factual = factual_data['Y'].values[0]\n",
                "y_counterfactual = counterfactual_data['Y'].values[0]\n",
                "print(f\"\\nFactual Y: {y_factual:.4f}\")\n",
                "print(f\"Counterfactual Y: {y_counterfactual:.4f}\")\n",
                "print(f\"Difference: {y_counterfactual - y_factual:.4f}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Summary\n",
                "\n",
                "In this notebook, we've explored Structural Causal Models (SCMs) in the causal meta-learning library:\n",
                "\n",
                "1. We created SCMs with both linear and non-linear structural equations\n",
                "2. We sampled observational data from these models\n",
                "3. We performed interventions to simulate experimental data\n",
                "4. We calculated direct, indirect, and total causal effects\n",
                "5. We visualized how interventions affect outcome distributions\n",
                "6. We performed counterfactual analysis on specific observations\n",
                "\n",
                "SCMs provide a powerful framework for causal modeling, enabling not just observational inference but also interventional and counterfactual reasoning."
            ]
        }
    ]
    # Notebook 5: Example Use Case
    example_cells = [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Example Use Case: Simulating a Treatment Effect Study\n",
                "\n",
                "This notebook demonstrates an end-to-end example of using the causal meta-learning library to simulate a treatment effect study. We'll:\n",
                "\n",
                "1. Define a causal graph structure\n",
                "2. Create a structural causal model (SCM)\n",
                "3. Generate synthetic data\n",
                "4. Analyze treatment effects\n",
                "5. Compare naive vs. causal estimation methods\n",
                "\n",
                "Let's get started!"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Import necessary modules\n",
                "import sys\n",
                "import os\n",
                "\n",
                "# Add the root directory to the path to make imports work\n",
                "root_dir = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
                "if root_dir not in sys.path:\n",
                "    sys.path.append(root_dir)\n",
                "\n",
                "# Import the necessary modules\n",
                "from causal_meta.graph import CausalGraph\n",
                "from causal_meta.environments.scm import StructuralCausalModel\n",
                "import causal_meta.graph.visualization as viz\n",
                "\n",
                "import numpy as np\n",
                "import pandas as pd\n",
                "import matplotlib.pyplot as plt\n",
                "import seaborn as sns\n",
                "from sklearn.linear_model import LinearRegression"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 1. Define Causal Graph Structure\n",
                "\n",
                "We'll model a simple medical treatment scenario with the following variables:\n",
                "- `Age`: Patient's age\n",
                "- `Severity`: Disease severity\n",
                "- `Treatment`: Whether the patient received treatment\n",
                "- `Recovery`: Patient's recovery outcome\n",
                "\n",
                "The causal structure represents a scenario where age affects disease severity, severity influences both treatment decisions and recovery outcomes, and treatment affects recovery."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create the causal graph\n",
                "graph = CausalGraph()\n",
                "\n",
                "# Add nodes\n",
                "nodes = ['Age', 'Severity', 'Treatment', 'Recovery']\n",
                "for node in nodes:\n",
                "    graph.add_node(node)\n",
                "\n",
                "# Add edges representing causal relationships\n",
                "graph.add_edge('Age', 'Severity')        # Age affects disease severity\n",
                "graph.add_edge('Severity', 'Treatment')  # Severity influences treatment decisions\n",
                "graph.add_edge('Severity', 'Recovery')   # Severity affects recovery\n",
                "graph.add_edge('Treatment', 'Recovery')  # Treatment affects recovery\n",
                "\n",
                "# Visualize the causal graph\n",
                "plt.figure(figsize=(10, 6))\n",
                "ax = plt.gca()\n",
                "viz.plot_causal_graph(graph, ax=ax, title=\"Causal Graph for Treatment Effect Study\")\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 2. Create a Structural Causal Model\n",
                "\n",
                "Now we'll define the structural equations that govern the relationships between variables."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create the SCM\n",
                "scm = StructuralCausalModel(causal_graph=graph)\n",
                "\n",
                "# Add variables with appropriate domains\n",
                "scm.add_variable('Age', domain='continuous')\n",
                "scm.add_variable('Severity', domain='continuous')\n",
                "scm.add_variable('Treatment', domain='binary')\n",
                "scm.add_variable('Recovery', domain='continuous')\n",
                "\n",
                "# Define structural equations\n",
                "\n",
                "# Age is exogenous, normally distributed around 50 with std=15\n",
                "scm.define_linear_gaussian_equation('Age', {}, intercept=50, noise_std=15)\n",
                "\n",
                "# Severity increases with age (0.03 units per year of age)\n",
                "scm.define_linear_gaussian_equation('Severity', {'Age': 0.03}, intercept=1, noise_std=0.5)\n",
                "\n",
                "# Treatment is more likely with higher severity (logistic function)\n",
                "def treatment_equation(Severity, noise):\n",
                "    # Logistic function to determine treatment probability\n",
                "    prob = 1 / (1 + np.exp(-2 * (Severity - 2.5)))\n",
                "    # Treatment = 1 if noise < prob, else 0\n",
                "    return 1 if noise < prob else 0\n",
                "\n",
                "scm.define_probabilistic_equation('Treatment', treatment_equation, lambda rng: rng.uniform(0, 1))\n",
                "\n",
                "# Recovery depends on severity (negatively) and treatment (positively)\n",
                "scm.define_linear_gaussian_equation('Recovery', \n",
                "                                  {'Severity': -0.7, 'Treatment': 1.5}, \n",
                "                                  intercept=5, \n",
                "                                  noise_std=0.3)\n",
                "\n",
                "print(scm)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 3. Generate Synthetic Data\n",
                "\n",
                "Let's generate observational data from our SCM to simulate an observational study."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Sample observational data\n",
                "obs_data = scm.sample_data(1000, random_seed=42)\n",
                "\n",
                "# Display the first few rows\n",
                "print(\"Observational data:\")\n",
                "print(obs_data.head())\n",
                "\n",
                "# Basic summary statistics\n",
                "print(\"\\nSummary statistics:\")\n",
                "print(obs_data.describe().round(2))\n",
                "\n",
                "# Calculate treatment rate\n",
                "treatment_rate = obs_data['Treatment'].mean() * 100\n",
                "print(f\"\\nTreatment rate: {treatment_rate:.1f}%\")\n",
                "\n",
                "# Visualize data distributions\n",
                "fig, axes = plt.subplots(2, 2, figsize=(12, 8))\n",
                "axes = axes.flatten()\n",
                "\n",
                "# Age distribution\n",
                "sns.histplot(obs_data['Age'], kde=True, ax=axes[0])\n",
                "axes[0].set_title('Age Distribution')\n",
                "\n",
                "# Severity distribution\n",
                "sns.histplot(obs_data['Severity'], kde=True, ax=axes[1])\n",
                "axes[1].set_title('Severity Distribution')\n",
                "\n",
                "# Treatment distribution\n",
                "sns.countplot(x='Treatment', data=obs_data, ax=axes[2])\n",
                "axes[2].set_title('Treatment Distribution')\n",
                "\n",
                "# Recovery distribution\n",
                "sns.histplot(obs_data['Recovery'], kde=True, ax=axes[3])\n",
                "axes[3].set_title('Recovery Distribution')\n",
                "\n",
                "plt.tight_layout()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Examining Relationships Between Variables"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Examine relationship between Severity and Treatment\n",
                "plt.figure(figsize=(10, 6))\n",
                "sns.boxplot(x='Treatment', y='Severity', data=obs_data)\n",
                "plt.title('Severity by Treatment Group')\n",
                "plt.grid(True, axis='y')\n",
                "plt.show()\n",
                "\n",
                "# Summary by treatment group\n",
                "treatment_summary = obs_data.groupby('Treatment').agg({\n",
                "    'Age': ['mean', 'std'],\n",
                "    'Severity': ['mean', 'std'],\n",
                "    'Recovery': ['mean', 'std', 'count']\n",
                "}).round(2)\n",
                "\n",
                "print(\"Summary by treatment group:\")\n",
                "print(treatment_summary)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 4. Analyze Treatment Effects\n",
                "\n",
                "Now let's analyze the treatment effect using both naive methods and causal inference techniques."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Naive approach: directly compare treatment groups\n",
                "treated = obs_data[obs_data['Treatment'] == 1]['Recovery'].mean()\n",
                "untreated = obs_data[obs_data['Treatment'] == 0]['Recovery'].mean()\n",
                "naive_effect = treated - untreated\n",
                "\n",
                "print(f\"Naive approach (simple difference in means):\")\n",
                "print(f\"  Treated group mean recovery: {treated:.3f}\")\n",
                "print(f\"  Untreated group mean recovery: {untreated:.3f}\")\n",
                "print(f\"  Estimated treatment effect: {naive_effect:.3f}\")\n",
                "\n",
                "# Adjustment approach: control for confounding using regression\n",
                "X = obs_data[['Treatment', 'Severity']]\n",
                "y = obs_data['Recovery']\n",
                "model = LinearRegression().fit(X, y)\n",
                "\n",
                "# The coefficient for Treatment in this model represents the adjusted effect\n",
                "adjusted_effect = model.coef_[0]\n",
                "\n",
                "print(f\"\\nAdjustment approach (linear regression with severity adjustment):\")\n",
                "print(f\"  Regression coefficients: Treatment={model.coef_[0]:.3f}, Severity={model.coef_[1]:.3f}, Intercept={model.intercept_:.3f}\")\n",
                "print(f\"  Adjusted treatment effect: {adjusted_effect:.3f}\")\n",
                "\n",
                "# Causal approach: use the SCM to perform interventions\n",
                "causal_effect = scm.compute_effect(\n",
                "    treatment='Treatment', \n",
                "    outcome='Recovery', \n",
                "    treatment_value=1, \n",
                "    baseline_value=0,\n",
                "    sample_size=5000, \n",
                "    random_seed=42\n",
                ")\n",
                "\n",
                "print(f\"\\nCausal approach (intervention-based using SCM):\")\n",
                "print(f\"  True causal effect: {causal_effect:.3f}\")\n",
                "print(f\"  True value defined in SCM: 1.5\")\n",
                "\n",
                "# Compare all approaches\n",
                "print(f\"\\nComparison of approaches:\")\n",
                "print(f\"  Naive estimate: {naive_effect:.3f}\")\n",
                "print(f\"  Adjusted estimate: {adjusted_effect:.3f}\")\n",
                "print(f\"  True causal effect: {causal_effect:.3f}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Visualizing the Confounding Effect"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Create interventional datasets\n",
                "scm.do_intervention('Treatment', 1)  # Everyone gets treatment\n",
                "treated_data = scm.sample_data(1000, random_seed=43)\n",
                "treated_data['Group'] = 'do(Treatment=1)'\n",
                "\n",
                "scm.reset()\n",
                "scm.do_intervention('Treatment', 0)  # No one gets treatment\n",
                "untreated_data = scm.sample_data(1000, random_seed=43)\n",
                "untreated_data['Group'] = 'do(Treatment=0)'\n",
                "\n",
                "# Create observational comparison data\n",
                "scm.reset()\n",
                "obs_comparison = obs_data.copy()\n",
                "obs_comparison['Group'] = 'Observed T=' + obs_comparison['Treatment'].astype(str)\n",
                "\n",
                "# Combine all data for visualization\n",
                "combined_data = pd.concat([treated_data, untreated_data, obs_comparison])\n",
                "\n",
                "# Plot recovery distributions\n",
                "plt.figure(figsize=(12, 6))\n",
                "sns.boxplot(x='Group', y='Recovery', data=combined_data, \n",
                "            order=['do(Treatment=1)', 'do(Treatment=0)', 'Observed T=1', 'Observed T=0'])\n",
                "plt.axhline(treated_data['Recovery'].mean(), color='r', linestyle='--', alpha=0.5)\n",
                "plt.axhline(untreated_data['Recovery'].mean(), color='b', linestyle='--', alpha=0.5)\n",
                "plt.title('Recovery Distributions: Interventional vs Observational')\n",
                "plt.grid(True, axis='y')\n",
                "plt.show()\n",
                "\n",
                "# Calculate means for each group\n",
                "means = combined_data.groupby('Group')['Recovery'].mean().reindex(\n",
                "    ['do(Treatment=1)', 'do(Treatment=0)', 'Observed T=1', 'Observed T=0'])\n",
                "print(\"Mean recovery by group:\")\n",
                "print(means)\n",
                "\n",
                "# Calculate true and naive effects\n",
                "true_effect = means['do(Treatment=1)'] - means['do(Treatment=0)']\n",
                "obs_effect = means['Observed T=1'] - means['Observed T=0']\n",
                "print(f\"\\nTrue causal effect: {true_effect:.3f}\")\n",
                "print(f\"Naive observational effect: {obs_effect:.3f}\")\n",
                "print(f\"Bias: {obs_effect - true_effect:.3f}\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Relationship Between Severity and Treatment Assignment"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Plot the relationship between severity and treatment probability\n",
                "severities = np.linspace(0, 5, 100)\n",
                "treatment_probs = 1 / (1 + np.exp(-2 * (severities - 2.5)))\n",
                "\n",
                "plt.figure(figsize=(10, 6))\n",
                "plt.plot(severities, treatment_probs, 'b-', linewidth=2)\n",
                "plt.xlabel('Severity')\n",
                "plt.ylabel('Probability of Treatment')\n",
                "plt.title('Treatment Assignment Probability by Disease Severity')\n",
                "plt.grid(True)\n",
                "plt.axhline(0.5, color='r', linestyle='--', alpha=0.5)\n",
                "plt.axvline(2.5, color='r', linestyle='--', alpha=0.5)\n",
                "plt.text(2.6, 0.52, 'Severity = 2.5', color='r')\n",
                "plt.ylim(0, 1)\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## 5. Exploring Counterfactuals\n",
                "\n",
                "Finally, let's examine some counterfactual scenarios for individual patients."
            ]
        },
        {
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Reset the SCM\n",
                "scm.reset()\n",
                "\n",
                "# Sample a few patients with different characteristics\n",
                "patients = scm.sample_data(3, random_seed=42)\n",
                "print(\"Sample patients:\")\n",
                "print(patients)\n",
                "\n",
                "# Perform counterfactual analysis for each patient\n",
                "results = []\n",
                "\n",
                "for i, patient in patients.iterrows():\n",
                "    patient_df = pd.DataFrame([patient])\n",
                "    actual_treatment = patient['Treatment']\n",
                "    counterfactual_treatment = 1 - actual_treatment\n",
                "    \n",
                "    # Evaluate counterfactual with opposite treatment\n",
                "    counterfactual = scm.evaluate_counterfactual(\n",
                "        factual_data=patient_df,\n",
                "        interventions={'Treatment': counterfactual_treatment}\n",
                "    )\n",
                "    \n",
                "    # Extract outcomes\n",
                "    factual_recovery = patient['Recovery']\n",
                "    counterfactual_recovery = counterfactual['Recovery'].values[0]\n",
                "    \n",
                "    # Individual treatment effect\n",
                "    if actual_treatment == 1:\n",
                "        ite = factual_recovery - counterfactual_recovery  # Effect of treatment vs. no treatment\n",
                "    else:\n",
                "        ite = counterfactual_recovery - factual_recovery  # Effect of treatment vs. no treatment\n",
                "    \n",
                "    results.append({\n",
                "        'Patient': i+1,\n",
                "        'Age': patient['Age'],\n",
                "        'Severity': patient['Severity'],\n",
                "        'Actual Treatment': actual_treatment,\n",
                "        'Actual Recovery': factual_recovery,\n",
                "        'Counterfactual Treatment': counterfactual_treatment,\n",
                "        'Counterfactual Recovery': counterfactual_recovery,\n",
                "        'Individual Treatment Effect': ite\n",
                "    })\n",
                "\n",
                "# Create results dataframe\n",
                "results_df = pd.DataFrame(results)\n",
                "print(\"\\nCounterfactual analysis results:\")\n",
                "print(results_df.round(3))\n",
                "\n",
                "# Visualize the individual treatment effects\n",
                "plt.figure(figsize=(12, 6))\n",
                "for i, row in results_df.iterrows():\n",
                "    plt.plot([row['Actual Treatment'], row['Counterfactual Treatment']], \n",
                "             [row['Actual Recovery'], row['Counterfactual Recovery']], \n",
                "             'o-', linewidth=2, label=f\"Patient {row['Patient']} (Severity={row['Severity']:.2f})\")\n",
                "    \n",
                "plt.xlabel('Treatment')\n",
                "plt.ylabel('Recovery')\n",
                "plt.title('Individual Treatment Effects')\n",
                "plt.xticks([0, 1], ['No Treatment', 'Treatment'])\n",
                "plt.grid(True)\n",
                "plt.legend()\n",
                "plt.show()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## Summary\n",
                "\n",
                "In this example, we demonstrated an end-to-end causal inference workflow:\n",
                "\n",
                "1. We defined a causal graph representing treatment effects with confounding\n",
                "2. We created a structural causal model with specific mechanisms\n",
                "3. We generated synthetic observational data from the SCM\n",
                "4. We analyzed the treatment effect using different approaches:\n",
                "   - The naive approach (direct comparison) was biased due to confounding\n",
                "   - The adjusted approach (regression) provided a better estimate\n",
                "   - The causal approach using interventions gave the true effect\n",
                "5. We evaluated counterfactual scenarios for individual patients\n",
                "\n",
                "This example illustrates the importance of causal reasoning in correctly estimating treatment effects, especially in the presence of confounding variables."
            ]
        }
    ]
    # Define all notebooks to create
    notebooks_to_create = [
        {
            "filename": "01_graph_classes_and_operations.ipynb",
            "title": "Graph Classes and Operations",
            "description": "This notebook demonstrates how to use the graph classes and operations in the causal meta-learning library.",
            "cells": graph_classes_cells
        },
        {
            "filename": "02_graph_visualization.ipynb",
            "title": "Graph Visualization",
            "description": "This notebook demonstrates techniques for visualizing different types of graphs in the causal meta-learning library.",
            "cells": visualization_cells
        },
        {
            "filename": "03_graph_generation.ipynb",
            "title": "Graph Generation",
            "description": "This notebook shows how to generate random graphs and common causal structures using the causal meta-learning library.",
            "cells": generation_cells
        },
        {
            "filename": "04_structural_causal_models.ipynb",
            "title": "Structural Causal Models",
            "description": "This notebook explores structural causal models (SCMs) and their applications in causal inference.",
            "cells": scm_cells
        },
        {
            "filename": "05_example_use_case.ipynb",
            "title": "Example Use Case: Medical Treatment Effect",
            "description": "This notebook demonstrates a complete workflow for estimating causal effects in a medical treatment scenario.",
            "cells": example_cells
        }
    ]

    for notebook in notebooks_to_create:
        create_notebook(**notebook)
