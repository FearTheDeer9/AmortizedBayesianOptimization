"""
Missing functions from documented API.

This module implements the documented functions that were missing from our implementation.
"""

import jax.numpy as jnp
import pyrsistent as pyr
from typing import List, Dict, Any, Optional

from .standardization import reverse_standardization, StandardizationParams
from .sample_adapter import create_sample_from_legacy

# Type aliases
SampleList = List[pyr.PMap]
VariableOrder = List[str]


def validate_data_conversion(
    original_samples: SampleList,
    converted_data: jnp.ndarray,
    variable_order: VariableOrder,
    target_variable: str,
    tolerance: float = 1e-6
) -> bool:
    """
    Validate that data conversion preserves all information.
    
    Args:
        original_samples: Original Sample objects
        converted_data: Converted AVICI data tensor [N, d, 3]
        variable_order: Variable order used in conversion
        target_variable: Target variable name
        tolerance: Tolerance for numerical comparisons
        
    Returns:
        True if conversion preserved all information, False otherwise
        
    Raises:
        ValueError: If inputs are inconsistent
    """
    # Validate basic structure
    if len(original_samples) != converted_data.shape[0]:
        raise ValueError(
            f"Sample count mismatch: {len(original_samples)} vs {converted_data.shape[0]}"
        )
    
    if len(variable_order) != converted_data.shape[1]:
        raise ValueError(
            f"Variable count mismatch: {len(variable_order)} vs {converted_data.shape[1]}"
        )
    
    if converted_data.shape[2] != 3:
        raise ValueError(f"Expected 3 channels, got {converted_data.shape[2]}")
    
    # Extract channels
    values_channel = converted_data[:, :, 0]
    intervention_channel = converted_data[:, :, 1]
    target_channel = converted_data[:, :, 2]
    
    # Validate target indicators
    target_idx = variable_order.index(target_variable)
    expected_target_indicators = jnp.zeros((len(original_samples), len(variable_order)))
    expected_target_indicators = expected_target_indicators.at[:, target_idx].set(1.0)
    
    if not jnp.allclose(target_channel, expected_target_indicators, atol=tolerance):
        return False
    
    # Validate intervention indicators
    for i, sample in enumerate(original_samples):
        expected_interventions = jnp.zeros(len(variable_order))
        
        # Handle both documented and legacy sample formats
        if 'intervention' in sample and sample['intervention'] is not None:
            # Documented format
            intervention_targets = set(sample['intervention']['variables'])
        elif 'intervention_type' in sample and sample['intervention_type'] is not None:
            # Legacy format
            intervention_targets = set(sample['intervention_targets'])
        else:
            intervention_targets = set()
        
        for j, var_name in enumerate(variable_order):
            if var_name in intervention_targets:
                expected_interventions = expected_interventions.at[j].set(1.0)
        
        if not jnp.allclose(intervention_channel[i], expected_interventions, atol=tolerance):
            return False
    
    return True


def reconstruct_samples_from_avici_data(
    avici_data: jnp.ndarray,
    variable_order: VariableOrder,
    target_variable: str,
    standardization_params: Optional[StandardizationParams] = None
) -> SampleList:
    """
    Reconstruct Sample objects from AVICI data tensor (for validation).
    
    Args:
        avici_data: AVICI data tensor [N, d, 3]
        variable_order: Variable order used in conversion
        target_variable: Target variable name
        standardization_params: Parameters for reversing standardization
        
    Returns:
        List of reconstructed Sample objects
        
    Note:
        This function is primarily for validation purposes.
        Standardization reversal is approximate if standardization_params not provided.
    """
    n_samples = avici_data.shape[0]
    reconstructed_samples = []
    
    # Extract channels
    values_channel = avici_data[:, :, 0]
    intervention_channel = avici_data[:, :, 1]
    
    # Reverse standardization if parameters provided
    if standardization_params is not None:
        values_channel = reverse_standardization(values_channel, standardization_params)
    
    for i in range(n_samples):
        # Extract values for this sample
        sample_values = {}
        for j, var_name in enumerate(variable_order):
            sample_values[var_name] = float(values_channel[i, j])
        
        # Extract intervention information
        intervention_targets = set()
        for j, var_name in enumerate(variable_order):
            if intervention_channel[i, j] > 0.5:  # Threshold for binary indicator
                intervention_targets.add(var_name)
        
        # Create Sample object in documented format
        if intervention_targets:
            intervention = pyr.m(
                type='perfect',  # Simplified - we don't know the exact type
                variables=pyr.s(*intervention_targets),
                parameters=pyr.m()
            )
        else:
            intervention = None
            
        sample = pyr.m(
            values=pyr.m(**sample_values),
            intervention=intervention,
            metadata=pyr.m()
        )
        
        reconstructed_samples.append(sample)
    
    return reconstructed_samples


def get_variable_order_from_scm(scm: pyr.PMap) -> VariableOrder:
    """
    Get a consistent variable ordering from an SCM.
    
    Args:
        scm: The structural causal model
        
    Returns:
        List of variable names in a consistent order
        
    Note:
        This is a simplified version. In a full implementation,
        would use topological_sort from scm module for proper ordering.
    """
    variables = scm['variables']
    
    # Handle different variable representations
    if isinstance(variables, (set, frozenset, pyr.PSet)):
        # Try to get topological order if edges are available
        if 'edges' in scm:
            try:
                return _topological_sort(variables, scm['edges'])
            except:
                # Fall back to sorted order if topological sort fails
                return sorted(variables)
        else:
            return sorted(variables)
    elif isinstance(variables, (list, tuple)):
        return list(variables)
    else:
        raise ValueError(f"SCM variables must be a set or list, got {type(variables)}")


def _topological_sort(variables: set, edges: set) -> List[str]:
    """
    Simple topological sort implementation.
    
    Args:
        variables: Set of variable names
        edges: Set of (parent, child) edges
        
    Returns:
        Topologically sorted variable list
    """
    # Build adjacency list and in-degree count
    adj_list = {var: [] for var in variables}
    in_degree = {var: 0 for var in variables}
    
    for parent, child in edges:
        adj_list[parent].append(child)
        in_degree[child] += 1
    
    # Kahn's algorithm
    queue = [var for var in variables if in_degree[var] == 0]
    result = []
    
    while queue:
        # Sort queue for deterministic ordering
        queue.sort()
        var = queue.pop(0)
        result.append(var)
        
        for neighbor in adj_list[var]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    if len(result) != len(variables):
        raise ValueError("Graph has cycles - cannot compute topological order")
    
    return result
